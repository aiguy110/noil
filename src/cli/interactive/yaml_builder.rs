use std::fmt::Write;
use std::path::PathBuf;

pub struct SourceEntry {
    pub id: String,
    pub path: PathBuf,
    pub timestamp_pattern: String,
    pub timestamp_format: String,
    pub read_start: String,
    pub follow: bool,
}

pub struct CollectorEndpoint {
    pub id: String,
    pub url: String,
}

pub struct InteractiveConfig {
    pub mode: String,
    pub sources: Vec<SourceEntry>,
    pub collector_listen: Option<String>,
    pub collector_endpoints: Vec<CollectorEndpoint>,
    pub storage_path: String,
    pub web_listen: String,
}

/// Escape a string for single-quoted YAML. In YAML single-quoted scalars,
/// the only escape is '' for a literal single quote.
fn yaml_single_quote(s: &str) -> String {
    format!("'{}'", s.replace('\'', "''"))
}

pub fn build_yaml(config: &InteractiveConfig) -> String {
    let mut out = String::new();

    // Header
    writeln!(out, "# =============================================================================").unwrap();
    writeln!(out, "# NOIL CONFIGURATION").unwrap();
    writeln!(out, "# =============================================================================").unwrap();
    writeln!(out, "# Generated by 'noil config init --interactive'").unwrap();
    writeln!(out, "#").unwrap();
    writeln!(out, "# Config file locations (in order of precedence):").unwrap();
    writeln!(out, "#   1. Path specified via --config argument").unwrap();
    writeln!(out, "#   2. ~/.config/noil/config.yml").unwrap();
    writeln!(out, "#   3. /etc/noil/config.yml").unwrap();
    writeln!(out).unwrap();

    // Mode
    if config.mode != "standalone" {
        writeln!(out, "# =============================================================================").unwrap();
        writeln!(out, "# OPERATION MODE").unwrap();
        writeln!(out, "# =============================================================================").unwrap();
        writeln!(out).unwrap();
        writeln!(out, "mode: {}", config.mode).unwrap();
        writeln!(out).unwrap();
    }

    // Sources (standalone + collector)
    if config.mode != "parent" && !config.sources.is_empty() {
        writeln!(out, "# =============================================================================").unwrap();
        writeln!(out, "# SOURCES").unwrap();
        writeln!(out, "# =============================================================================").unwrap();
        writeln!(out, "# Log files to ingest. Each source needs a unique ID and timestamp config.").unwrap();
        writeln!(out).unwrap();
        writeln!(out, "sources:").unwrap();

        for (i, source) in config.sources.iter().enumerate() {
            if i > 0 {
                writeln!(out).unwrap();
            }
            writeln!(out, "  {}:", source.id).unwrap();
            writeln!(out, "    type: file").unwrap();
            writeln!(out, "    path: {}", source.path.display()).unwrap();
            writeln!(out, "    timestamp:").unwrap();
            writeln!(out, "      pattern: {}", yaml_single_quote(&source.timestamp_pattern)).unwrap();
            writeln!(out, "      format: {}", yaml_single_quote(&source.timestamp_format)).unwrap();
            writeln!(out, "    read:").unwrap();
            writeln!(out, "      start: {}", source.read_start).unwrap();
            writeln!(out, "      follow: {}", source.follow).unwrap();
        }
        writeln!(out).unwrap();
    }

    // Fiber types placeholder (standalone only)
    if config.mode == "standalone" {
        writeln!(out, "# =============================================================================").unwrap();
        writeln!(out, "# FIBER TYPES").unwrap();
        writeln!(out, "# =============================================================================").unwrap();
        writeln!(out, "# Define rules for correlating logs into fibers.").unwrap();
        writeln!(out, "# See the sample config for detailed examples.").unwrap();
        writeln!(out, "#").unwrap();
        writeln!(out, "# fiber_types:").unwrap();
        writeln!(out, "#   my_fiber:").unwrap();
        writeln!(out, "#     description: \"My fiber type\"").unwrap();
        writeln!(out, "#     temporal:").unwrap();
        writeln!(out, "#       max_gap: 5s").unwrap();
        writeln!(out, "#       gap_mode: session").unwrap();
        writeln!(out, "#     attributes:").unwrap();
        writeln!(out, "#       - name: my_key").unwrap();
        writeln!(out, "#         type: string").unwrap();
        writeln!(out, "#         key: true").unwrap();
        writeln!(out, "#     sources:").unwrap();
        writeln!(out, "#       my_source:").unwrap();
        writeln!(out, "#         patterns:").unwrap();
        writeln!(out, "#           - regex: '.+'").unwrap();
        writeln!(out).unwrap();
    }

    // Parent mode: fiber types placeholder + parent config
    if config.mode == "parent" {
        writeln!(out, "# =============================================================================").unwrap();
        writeln!(out, "# PARENT MODE CONFIGURATION").unwrap();
        writeln!(out, "# =============================================================================").unwrap();
        writeln!(out).unwrap();
        writeln!(out, "parent:").unwrap();
        writeln!(out, "  collectors:").unwrap();

        for endpoint in &config.collector_endpoints {
            writeln!(out, "    - id: {}", endpoint.id).unwrap();
            writeln!(out, "      url: {}", endpoint.url).unwrap();
            writeln!(out, "      retry_interval: 5s").unwrap();
            writeln!(out, "      timeout: 30s").unwrap();
        }

        writeln!(out, "  poll_interval: 1s").unwrap();
        writeln!(out, "  backpressure:").unwrap();
        writeln!(out, "    strategy: block").unwrap();
        writeln!(out, "    buffer_limit: 10000").unwrap();
        writeln!(out).unwrap();

        writeln!(out, "# =============================================================================").unwrap();
        writeln!(out, "# FIBER TYPES").unwrap();
        writeln!(out, "# =============================================================================").unwrap();
        writeln!(out, "# Define fiber correlation rules for logs from collectors.").unwrap();
        writeln!(out, "# Source names must match those defined in collector configs.").unwrap();
        writeln!(out, "#").unwrap();
        writeln!(out, "# fiber_types:").unwrap();
        writeln!(out, "#   my_fiber:").unwrap();
        writeln!(out, "#     description: \"My fiber type\"").unwrap();
        writeln!(out, "#     temporal:").unwrap();
        writeln!(out, "#       max_gap: 5s").unwrap();
        writeln!(out, "#       gap_mode: session").unwrap();
        writeln!(out, "#     attributes:").unwrap();
        writeln!(out, "#       - name: my_key").unwrap();
        writeln!(out, "#         type: string").unwrap();
        writeln!(out, "#         key: true").unwrap();
        writeln!(out, "#     sources:").unwrap();
        writeln!(out, "#       source_from_collector:").unwrap();
        writeln!(out, "#         patterns:").unwrap();
        writeln!(out, "#           - regex: '.+'").unwrap();
        writeln!(out).unwrap();
    }

    // Collector mode config
    if config.mode == "collector" {
        writeln!(out, "# =============================================================================").unwrap();
        writeln!(out, "# COLLECTOR MODE CONFIGURATION").unwrap();
        writeln!(out, "# =============================================================================").unwrap();
        writeln!(out).unwrap();
        writeln!(out, "collector:").unwrap();
        writeln!(out, "  listen: {}", config.collector_listen.as_deref().unwrap_or("0.0.0.0:7105")).unwrap();
        writeln!(out, "  epoch_duration: 10s").unwrap();
        writeln!(out, "  buffer:").unwrap();
        writeln!(out, "    max_epochs: 100").unwrap();
        writeln!(out, "    strategy: block").unwrap();
        writeln!(out, "  checkpoint:").unwrap();
        writeln!(out, "    enabled: true").unwrap();
        writeln!(out, "    interval_seconds: 30").unwrap();
        writeln!(out, "  status_ui:").unwrap();
        writeln!(out, "    enabled: true").unwrap();
        writeln!(out).unwrap();

        // Sequencer for collector
        writeln!(out, "# =============================================================================").unwrap();
        writeln!(out, "# SEQUENCER SETTINGS").unwrap();
        writeln!(out, "# =============================================================================").unwrap();
        writeln!(out).unwrap();
        writeln!(out, "sequencer:").unwrap();
        writeln!(out, "  watermark_safety_margin: 5s").unwrap();
        writeln!(out).unwrap();
    }

    // Pipeline (standalone + parent)
    if config.mode != "collector" {
        writeln!(out, "# =============================================================================").unwrap();
        writeln!(out, "# PIPELINE SETTINGS").unwrap();
        writeln!(out, "# =============================================================================").unwrap();
        writeln!(out).unwrap();
        writeln!(out, "pipeline:").unwrap();
        writeln!(out, "  backpressure:").unwrap();
        writeln!(out, "    strategy: block").unwrap();
        writeln!(out, "    buffer_limit: 10000").unwrap();
        writeln!(out, "  errors:").unwrap();
        writeln!(out, "    on_parse_error: drop").unwrap();
        writeln!(out, "  checkpoint:").unwrap();
        writeln!(out, "    enabled: true").unwrap();
        writeln!(out, "    interval_seconds: 30").unwrap();
        writeln!(out).unwrap();

        // Sequencer for standalone/parent
        writeln!(out, "# =============================================================================").unwrap();
        writeln!(out, "# SEQUENCER SETTINGS").unwrap();
        writeln!(out, "# =============================================================================").unwrap();
        writeln!(out).unwrap();
        writeln!(out, "sequencer:").unwrap();
        writeln!(out, "  batch_epoch_duration: 10s").unwrap();
        writeln!(out, "  watermark_safety_margin: 1s").unwrap();
        writeln!(out).unwrap();
    } else {
        // Collector still needs pipeline.checkpoint
        writeln!(out, "# =============================================================================").unwrap();
        writeln!(out, "# PIPELINE SETTINGS").unwrap();
        writeln!(out, "# =============================================================================").unwrap();
        writeln!(out).unwrap();
        writeln!(out, "pipeline:").unwrap();
        writeln!(out, "  checkpoint:").unwrap();
        writeln!(out, "    enabled: true").unwrap();
        writeln!(out, "    interval_seconds: 30").unwrap();
        writeln!(out).unwrap();
    }

    // Storage
    writeln!(out, "# =============================================================================").unwrap();
    writeln!(out, "# STORAGE SETTINGS").unwrap();
    writeln!(out, "# =============================================================================").unwrap();
    writeln!(out).unwrap();
    writeln!(out, "storage:").unwrap();
    writeln!(out, "  path: {}", config.storage_path).unwrap();
    writeln!(out, "  batch_size: 1000").unwrap();
    writeln!(out, "  flush_interval_seconds: 5").unwrap();
    writeln!(out).unwrap();

    // Web
    writeln!(out, "# =============================================================================").unwrap();
    writeln!(out, "# WEB SERVER SETTINGS").unwrap();
    writeln!(out, "# =============================================================================").unwrap();
    writeln!(out).unwrap();
    writeln!(out, "web:").unwrap();
    writeln!(out, "  listen: {}", config.web_listen).unwrap();

    out
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_build_standalone_yaml() {
        let config = InteractiveConfig {
            mode: "standalone".to_string(),
            sources: vec![SourceEntry {
                id: "my_log".to_string(),
                path: PathBuf::from("/var/log/app.log"),
                timestamp_pattern: r"^(?P<ts>\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}\.\d+Z)".to_string(),
                timestamp_format: "iso8601".to_string(),
                read_start: "beginning".to_string(),
                follow: true,
            }],
            collector_listen: None,
            collector_endpoints: vec![],
            storage_path: "/var/lib/noil/noil.duckdb".to_string(),
            web_listen: "127.0.0.1:7104".to_string(),
        };

        let yaml = build_yaml(&config);
        assert!(yaml.contains("sources:"));
        assert!(yaml.contains("my_log:"));
        assert!(yaml.contains("/var/log/app.log"));
        assert!(yaml.contains("format: 'iso8601'"));
        assert!(yaml.contains("follow: true"));
        assert!(yaml.contains("# fiber_types:"));
        assert!(yaml.contains("pipeline:"));
        assert!(yaml.contains("storage:"));
        assert!(yaml.contains("web:"));
        // Standalone should not have mode line
        assert!(!yaml.contains("\nmode:"));
    }

    #[test]
    fn test_build_collector_yaml() {
        let config = InteractiveConfig {
            mode: "collector".to_string(),
            sources: vec![SourceEntry {
                id: "syslog".to_string(),
                path: PathBuf::from("/var/log/syslog"),
                timestamp_pattern: r"^(?P<ts>\S+)".to_string(),
                timestamp_format: "iso8601".to_string(),
                read_start: "end".to_string(),
                follow: true,
            }],
            collector_listen: Some("0.0.0.0:7105".to_string()),
            collector_endpoints: vec![],
            storage_path: "$env{TMPDIR}/noil-collector.duckdb".to_string(),
            web_listen: "0.0.0.0:7105".to_string(),
        };

        let yaml = build_yaml(&config);
        assert!(yaml.contains("mode: collector"));
        assert!(yaml.contains("collector:"));
        assert!(yaml.contains("listen: 0.0.0.0:7105"));
        assert!(yaml.contains("epoch_duration: 10s"));
        // Collector should not have fiber_types
        assert!(!yaml.contains("# fiber_types:"));
    }

    #[test]
    fn test_build_parent_yaml() {
        let config = InteractiveConfig {
            mode: "parent".to_string(),
            sources: vec![],
            collector_listen: None,
            collector_endpoints: vec![
                CollectorEndpoint {
                    id: "node1".to_string(),
                    url: "http://192.168.1.10:7105".to_string(),
                },
                CollectorEndpoint {
                    id: "node2".to_string(),
                    url: "http://192.168.1.11:7105".to_string(),
                },
            ],
            storage_path: "/var/lib/noil/noil-parent.duckdb".to_string(),
            web_listen: "0.0.0.0:7104".to_string(),
        };

        let yaml = build_yaml(&config);
        assert!(yaml.contains("mode: parent"));
        assert!(yaml.contains("parent:"));
        assert!(yaml.contains("- id: node1"));
        assert!(yaml.contains("url: http://192.168.1.10:7105"));
        assert!(yaml.contains("- id: node2"));
        // Parent should not have sources section
        assert!(!yaml.contains("\nsources:"));
    }

    #[test]
    fn test_yaml_single_quote_escaping() {
        assert_eq!(yaml_single_quote("hello"), "'hello'");
        assert_eq!(yaml_single_quote("it's"), "'it''s'");
        assert_eq!(yaml_single_quote("a'b'c"), "'a''b''c'");
    }
}
