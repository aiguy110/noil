use std::fmt::Write;
use std::path::PathBuf;

pub struct SourceEntry {
    pub id: String,
    pub path: PathBuf,
    pub timestamp_pattern: String,
    pub timestamp_format: String,
    pub read_start: String,
    pub follow: bool,
}

pub struct CollectorEndpoint {
    pub id: String,
    pub url: String,
}

pub struct InteractiveConfig {
    pub sources: Vec<SourceEntry>,
    pub collector_endpoints: Vec<CollectorEndpoint>,
    pub enable_collector_serving: bool,
    pub enable_log_storage: bool,
    pub storage_path: String,
    pub web_listen: String,
}

/// Escape a string for single-quoted YAML. In YAML single-quoted scalars,
/// the only escape is '' for a literal single quote.
fn yaml_single_quote(s: &str) -> String {
    format!("'{}'", s.replace('\'', "''"))
}

pub fn build_yaml(config: &InteractiveConfig) -> String {
    let mut out = String::new();

    // Header
    writeln!(out, "# =============================================================================").unwrap();
    writeln!(out, "# NOIL CONFIGURATION").unwrap();
    writeln!(out, "# =============================================================================").unwrap();
    writeln!(out, "# Generated by 'noil config init --interactive'").unwrap();
    writeln!(out, "#").unwrap();
    writeln!(out, "# Capabilities are determined by which sections are present:").unwrap();
    writeln!(out, "#   - sources:             Read local log files").unwrap();
    writeln!(out, "#   - remote_collectors:   Pull logs from remote Noil instances").unwrap();
    writeln!(out, "#   - collector:           Serve logs to other Noil instances").unwrap();
    writeln!(out, "#   - fiber_types:         Enable log storage and fiber processing").unwrap();
    writeln!(out, "#").unwrap();
    writeln!(out, "# Config file locations (in order of precedence):").unwrap();
    writeln!(out, "#   1. Path specified via --config argument").unwrap();
    writeln!(out, "#   2. ~/.config/noil/config.yml").unwrap();
    writeln!(out, "#   3. /etc/noil/config.yml").unwrap();
    writeln!(out).unwrap();

    // Sources
    if !config.sources.is_empty() {
        writeln!(out, "# =============================================================================").unwrap();
        writeln!(out, "# SOURCES").unwrap();
        writeln!(out, "# =============================================================================").unwrap();
        writeln!(out, "# Log files to ingest. Each source needs a unique ID and timestamp config.").unwrap();
        writeln!(out).unwrap();
        writeln!(out, "sources:").unwrap();

        for (i, source) in config.sources.iter().enumerate() {
            if i > 0 {
                writeln!(out).unwrap();
            }
            writeln!(out, "  {}:", source.id).unwrap();
            writeln!(out, "    type: file").unwrap();
            writeln!(out, "    path: {}", source.path.display()).unwrap();
            writeln!(out, "    timestamp:").unwrap();
            writeln!(out, "      pattern: {}", yaml_single_quote(&source.timestamp_pattern)).unwrap();
            writeln!(out, "      format: {}", yaml_single_quote(&source.timestamp_format)).unwrap();
            writeln!(out, "    read:").unwrap();
            writeln!(out, "      start: {}", source.read_start).unwrap();
            writeln!(out, "      follow: {}", source.follow).unwrap();
        }
        writeln!(out).unwrap();
    }

    // Remote collectors
    if !config.collector_endpoints.is_empty() {
        writeln!(out, "# =============================================================================").unwrap();
        writeln!(out, "# REMOTE COLLECTORS").unwrap();
        writeln!(out, "# =============================================================================").unwrap();
        writeln!(out, "# Pull logs from remote Noil instances running as collectors.").unwrap();
        writeln!(out).unwrap();
        writeln!(out, "remote_collectors:").unwrap();
        writeln!(out, "  endpoints:").unwrap();

        for endpoint in &config.collector_endpoints {
            writeln!(out, "    - id: {}", endpoint.id).unwrap();
            writeln!(out, "      url: {}", endpoint.url).unwrap();
            writeln!(out, "      retry_interval: 5s").unwrap();
            writeln!(out, "      timeout: 30s").unwrap();
        }

        writeln!(out, "  poll_interval: 1s").unwrap();
        writeln!(out, "  backpressure:").unwrap();
        writeln!(out, "    strategy: block").unwrap();
        writeln!(out, "    buffer_limit: 10000").unwrap();
        writeln!(out).unwrap();
    }

    // Collector serving
    if config.enable_collector_serving {
        writeln!(out, "# =============================================================================").unwrap();
        writeln!(out, "# COLLECTOR SERVING").unwrap();
        writeln!(out, "# =============================================================================").unwrap();
        writeln!(out, "# Serve collected logs to other Noil instances.").unwrap();
        writeln!(out).unwrap();
        writeln!(out, "collector:").unwrap();
        writeln!(out, "  epoch_duration: 10s").unwrap();
        writeln!(out, "  buffer:").unwrap();
        writeln!(out, "    max_epochs: 100").unwrap();
        writeln!(out, "    strategy: block").unwrap();
        writeln!(out, "  checkpoint:").unwrap();
        writeln!(out, "    enabled: true").unwrap();
        writeln!(out, "    interval_seconds: 30").unwrap();
        writeln!(out, "  status_ui:").unwrap();
        writeln!(out, "    enabled: true").unwrap();
        writeln!(out).unwrap();
    }

    // Fiber types
    if config.enable_log_storage {
        writeln!(out, "# =============================================================================").unwrap();
        writeln!(out, "# FIBER TYPES").unwrap();
        writeln!(out, "# =============================================================================").unwrap();
        writeln!(out, "# Define rules for correlating logs into fibers.").unwrap();
        writeln!(out, "# The presence of this key enables log storage and fiber processing.").unwrap();
        writeln!(out, "# Even empty (no rules), raw logs will be stored.").unwrap();
        writeln!(out, "# See the sample config for detailed fiber type examples.").unwrap();
        writeln!(out).unwrap();
        writeln!(out, "fiber_types:").unwrap();
        writeln!(out, "# Example fiber type (uncomment and modify):").unwrap();
        writeln!(out, "#   my_fiber:").unwrap();
        writeln!(out, "#     description: \"My fiber type\"").unwrap();
        writeln!(out, "#     temporal:").unwrap();
        writeln!(out, "#       max_gap: 5s").unwrap();
        writeln!(out, "#       gap_mode: session").unwrap();
        writeln!(out, "#     attributes:").unwrap();
        writeln!(out, "#       - name: my_key").unwrap();
        writeln!(out, "#         type: string").unwrap();
        writeln!(out, "#         key: true").unwrap();
        writeln!(out, "#     sources:").unwrap();
        writeln!(out, "#       my_source:").unwrap();
        writeln!(out, "#         patterns:").unwrap();
        writeln!(out, "#           - regex: '.+'").unwrap();
        writeln!(out).unwrap();
    } else {
        writeln!(out, "# =============================================================================").unwrap();
        writeln!(out, "# LOG STORAGE DISABLED").unwrap();
        writeln!(out, "# =============================================================================").unwrap();
        writeln!(out, "# To enable log storage and fiber processing, add a fiber_types: section.").unwrap();
        writeln!(out, "# Even an empty 'fiber_types: {{}}' enables raw log storage without fiber rules.").unwrap();
        writeln!(out).unwrap();
    }

    // Pipeline
    writeln!(out, "# =============================================================================").unwrap();
    writeln!(out, "# PIPELINE SETTINGS").unwrap();
    writeln!(out, "# =============================================================================").unwrap();
    writeln!(out).unwrap();
    writeln!(out, "pipeline:").unwrap();
    writeln!(out, "  backpressure:").unwrap();
    writeln!(out, "    strategy: block").unwrap();
    writeln!(out, "    buffer_limit: 10000").unwrap();
    writeln!(out, "  errors:").unwrap();
    writeln!(out, "    on_parse_error: drop").unwrap();
    writeln!(out, "  checkpoint:").unwrap();
    writeln!(out, "    enabled: true").unwrap();
    writeln!(out, "    interval_seconds: 30").unwrap();
    writeln!(out).unwrap();

    // Sequencer
    writeln!(out, "# =============================================================================").unwrap();
    writeln!(out, "# SEQUENCER SETTINGS").unwrap();
    writeln!(out, "# =============================================================================").unwrap();
    writeln!(out).unwrap();
    writeln!(out, "sequencer:").unwrap();
    writeln!(out, "  batch_epoch_duration: 10s").unwrap();
    writeln!(out, "  watermark_safety_margin: 1s").unwrap();
    writeln!(out).unwrap();

    // Storage
    writeln!(out, "# =============================================================================").unwrap();
    writeln!(out, "# STORAGE SETTINGS").unwrap();
    writeln!(out, "# =============================================================================").unwrap();
    writeln!(out).unwrap();
    writeln!(out, "storage:").unwrap();
    writeln!(out, "  path: {}", config.storage_path).unwrap();
    writeln!(out, "  batch_size: 1000").unwrap();
    writeln!(out, "  flush_interval_seconds: 5").unwrap();
    writeln!(out).unwrap();

    // Web
    writeln!(out, "# =============================================================================").unwrap();
    writeln!(out, "# WEB SERVER SETTINGS").unwrap();
    writeln!(out, "# =============================================================================").unwrap();
    writeln!(out).unwrap();
    writeln!(out, "web:").unwrap();
    writeln!(out, "  listen: {}", config.web_listen).unwrap();

    out
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_build_standalone_yaml() {
        let config = InteractiveConfig {
            sources: vec![SourceEntry {
                id: "my_log".to_string(),
                path: PathBuf::from("/var/log/app.log"),
                timestamp_pattern: r"^(?P<ts>\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}\.\d+Z)".to_string(),
                timestamp_format: "iso8601".to_string(),
                read_start: "beginning".to_string(),
                follow: true,
            }],
            collector_endpoints: vec![],
            enable_collector_serving: false,
            enable_log_storage: true,
            storage_path: "/var/lib/noil/noil.duckdb".to_string(),
            web_listen: "127.0.0.1:7104".to_string(),
        };

        let yaml = build_yaml(&config);
        assert!(yaml.contains("sources:"));
        assert!(yaml.contains("my_log:"));
        assert!(yaml.contains("/var/log/app.log"));
        assert!(yaml.contains("format: 'iso8601'"));
        assert!(yaml.contains("follow: true"));
        assert!(yaml.contains("pipeline:"));
        assert!(yaml.contains("storage:"));
        assert!(yaml.contains("web:"));
        assert!(!yaml.contains("\nmode:"));
        assert!(!yaml.contains("\ncollector:"));
        assert!(!yaml.contains("\nremote_collectors:"));
        // fiber_types: key present (enables log storage)
        assert!(yaml.contains("\nfiber_types:"));
    }

    #[test]
    fn test_build_collector_serving_yaml() {
        let config = InteractiveConfig {
            sources: vec![SourceEntry {
                id: "syslog".to_string(),
                path: PathBuf::from("/var/log/syslog"),
                timestamp_pattern: r"^(?P<ts>\S+)".to_string(),
                timestamp_format: "iso8601".to_string(),
                read_start: "end".to_string(),
                follow: true,
            }],
            collector_endpoints: vec![],
            enable_collector_serving: true,
            enable_log_storage: false,
            storage_path: "$env{TMPDIR}/noil-collector.duckdb".to_string(),
            web_listen: "0.0.0.0:7105".to_string(),
        };

        let yaml = build_yaml(&config);
        assert!(yaml.contains("collector:"));
        assert!(yaml.contains("epoch_duration: 10s"));
        assert!(yaml.contains("sources:"));
        // Log storage disabled
        assert!(!yaml.contains("# fiber_types:"));
        assert!(yaml.contains("LOG STORAGE DISABLED"));
    }

    #[test]
    fn test_build_remote_collectors_yaml() {
        let config = InteractiveConfig {
            sources: vec![],
            collector_endpoints: vec![
                CollectorEndpoint {
                    id: "node1".to_string(),
                    url: "http://192.168.1.10:7105".to_string(),
                },
                CollectorEndpoint {
                    id: "node2".to_string(),
                    url: "http://192.168.1.11:7105".to_string(),
                },
            ],
            enable_collector_serving: false,
            enable_log_storage: true,
            storage_path: "/var/lib/noil/noil-parent.duckdb".to_string(),
            web_listen: "0.0.0.0:7104".to_string(),
        };

        let yaml = build_yaml(&config);
        assert!(yaml.contains("remote_collectors:"));
        assert!(yaml.contains("endpoints:"));
        assert!(yaml.contains("- id: node1"));
        assert!(yaml.contains("url: http://192.168.1.10:7105"));
        assert!(yaml.contains("- id: node2"));
        // fiber_types: key present (enables log storage)
        assert!(yaml.contains("\nfiber_types:"));
        // Should not have sources section
        assert!(!yaml.contains("\nsources:"));
    }

    #[test]
    fn test_yaml_single_quote_escaping() {
        assert_eq!(yaml_single_quote("hello"), "'hello'");
        assert_eq!(yaml_single_quote("it's"), "'it''s'");
        assert_eq!(yaml_single_quote("a'b'c"), "'a''b''c'");
    }
}
